.model small
.stack 100h

.data
    ; System Messages
    welcome_msg db 'Welcome to Food Ordering System', 0Dh, 0Ah, '$'
    login_prompt db 'Enter username: $'
    pass_prompt db 0Dh, 0Ah, 'Enter password: $'
    login_success db 0Dh, 0Ah, 'Login successful!$'
    login_fail db 0Dh, 0Ah, 'Invalid credentials. Try again.$'
    login_lockout db 0Dh, 0Ah, 'Too many failed attempts. System exiting.$'
    
    ; Credentials
    valid_user db 'admin$'
    valid_pass db '1234$'
    
    ; Menu System
    main_menu db 0Dh, 0Ah, 'MAIN MENU', 0Dh, 0Ah, 0Dh, 0Ah
              db '1. View Food Menu', 0Dh, 0Ah
              db '2. View Cart', 0Dh, 0Ah
              db '3. Checkout', 0Dh, 0Ah
              db '4. Exit System', 0Dh, 0Ah, 0Dh, 0Ah
              db 'Enter choice (1-4): $'
    
    invalid_choice db 0Dh, 0Ah, 'Invalid selection. Please enter 1-4.$'
    
    ; Food Items
    food_menu db 0Dh, 0Ah, 'FOOD MENU', 0Dh, 0Ah, 0Dh, 0Ah
              db '1. Burger - 5', 0Dh, 0Ah
              db '2. Pizza - 8', 0Dh, 0Ah
              db '3. Salad - 6', 0Dh, 0Ah
              db '4. Fries - 3', 0Dh, 0Ah
              db '5. Drink - 2', 0Dh, 0Ah, 0Dh, 0Ah
              db 'Enter item number (1-5) or 0 to return: $'
    
    ; Cart Messages
    cart_header db 0Dh, 0Ah, 'YOUR CART', 0Dh, 0Ah, 0Dh, 0Ah, '$'
    empty_cart db 'Your cart is empty.$'
    item_added db 0Dh, 0Ah, 'Item added to cart.$'
    item_quantity_msg db ' - Quantity: $'
    
    ; System Buffers
    username db 20 dup('$')
    password db 20 dup('$')
    input_buffer db 2 dup('$')
    
    ; Cart Storage
    cart_items db 5 dup(0)      ; Stores item numbers (1-5)
    cart_quantities db 5 dup(0) ; Stores quantities
    cart_count db 0             ; Number of items in cart

.code
main proc
    mov ax, @data
    mov ds, ax
    mov es, ax       ; ES = DS for string operations
    
    call clear_screen
    call login_module
    cmp ax, 1          ; Check if login was successful
    jne exit_program   ; If not, exit
    
    call main_menu_module
    
exit_program:
    mov ax, 4C00h      ; DOS exit function
    int 21h
main endp

; ----------------------------
; LOGIN MODULE
; Returns: AX=1 if success, 0 if fail
; ----------------------------
login_module proc
    push bx
    push cx
    mov cx, 3          ; 3 attempts
    
attempt_loop:
    ; Display welcome message
    mov dx, offset welcome_msg
    call print_string
    
    ; Get username
    mov dx, offset login_prompt
    call print_string
    mov dx, offset username
    call get_string
    
    ; Get password
    mov dx, offset pass_prompt
    call print_string
    mov dx, offset password
    call get_string
    
    ; Validate credentials
    mov si, offset valid_user
    mov di, offset username
    call compare_strings
    cmp ax, 1
    je invalid_login
    
    mov si, offset valid_pass
    mov di, offset password
    call compare_strings
    cmp ax, 1
    je invalid_login
    
    ; Valid credentials
    mov dx, offset login_success
    call print_string
    mov ax, 1
    jmp login_done
    
invalid_login:
    dec cx
    jz lockout
    
    mov dx, offset login_fail
    call print_string
    jmp attempt_loop
    
lockout:
    mov dx, offset login_lockout
    call print_string
    xor ax, ax
    
login_done:
    pop cx
    pop bx
    ret
login_module endp

; ----------------------------
; MAIN MENU MODULE
; ----------------------------
main_menu_module proc
    push bx
    
menu_loop:
    call clear_screen
    mov dx, offset main_menu
    call print_string
    
    ; Get user selection
    call get_char
    mov bl, al
    
    ; Process selection
    cmp bl, '1'
    je show_menu
    cmp bl, '2'
    je show_cart
    cmp bl, '3'
    je checkout
    cmp bl, '4'
    je menu_exit
    
    ; Invalid choice
    mov dx, offset invalid_choice
    call print_string
    call wait_key
    jmp menu_loop
    
show_menu:
    call food_menu_module
    jmp menu_loop
    
show_cart:
    call display_cart
    call wait_key
    jmp menu_loop
    
checkout:
    call checkout_module
    jmp menu_loop
    
menu_exit:
    pop bx
    ret
main_menu_module endp

; ----------------------------
; FOOD MENU MODULE
; ----------------------------
food_menu_module proc
    push bx
    
menuloop:
    call clear_screen
    mov dx, offset food_menu
    call print_string
    
    ; Get selection
    call get_char
    mov bl, al
    
    ; Check for return (0)
    cmp bl, '0'
    je menu_done
    
    ; Validate input (1-5)
    cmp bl, '1'
    jb invalid_input
    cmp bl, '5'
    ja invalid_input
    
    ; Process selection
    sub bl, '0'  ; Convert to number
    
    ; Add to cart
    call add_to_cart
    mov dx, offset item_added
    call print_string
    call wait_key
    jmp menu_loop
    
invalid_input:
    ; Handle invalid input
    jmp menu_loop
    
menu_done:
    pop bx
    ret
food_menu_module endp

; ----------------------------
; CHECKOUT MODULE
; ----------------------------
checkout_module proc
    call clear_screen
    cmp [cart_count], 0
    jne has_items
    
    mov dx, offset empty_cart
    call print_string
    call wait_key
    ret
    
has_items:
    call display_cart
    
    ; Display total (simplified)
    mov dx, offset checkout_msg
    call print_string
    
    call wait_key
    ret
    
checkout_msg db 0Dh, 0Ah, 'Thank you for your order! Press any key to continue...$'
checkout_module endp

; ----------------------------
; CART FUNCTIONS
; ----------------------------
add_to_cart proc
    push si
    push di
    push cx
    
    ; Check if item already in cart
    mov si, offset cart_items
    mov di, offset cart_quantities
    mov cx, 0
    mov cl, [cart_count]
    jcxz add_new_item
    
search_loop:
    cmp [si], bl
    je increment_quantity
    inc si
    inc di
    loop search_loop
    
add_new_item:
    ; Add new item to cart
    mov si, offset cart_items
    mov al, [cart_count] ; Load 8-bit value into AL
    cbw                  ; Sign-extend AL to AX (AX = AL, AH = 0)
    add si, ax           ; Add 16-bit AX to SI
    mov [si], bl
    
    ; Set default quantity to 1
    mov di, offset cart_quantities
    mov al, [cart_count] ; Load 8-bit value into AL
    cbw                  ; Sign-extend AL to AX (AX = AL, AH = 0)
    add di, ax           ; Add 16-bit AX to DI
    mov byte ptr [di], 1
    
    ; Increment cart count
    inc [cart_count]
    jmp add_done
    
increment_quantity:
    ; Increment existing item quantity
    inc byte ptr [di]
    
add_done:
    pop cx
    pop di
    pop si
    ret
add_to_cart endp

display_cart proc
    push si
    push di
    push cx
    push dx
    
    call clear_screen
    mov dx, offset cart_header
    call print_string
    
    ; Check if cart is empty
    cmp [cart_count], 0
    jne show_items
    
    mov dx, offset empty_cart
    call print_string
    jmp display_done
    
show_items:
    ; Display cart items
    mov si, offset cart_items
    mov di, offset cart_quantities
    mov cx, 0
    mov cl, [cart_count]
    
display_loop:
    ; Display item number
    mov dl, [si]
    add dl, '0'
    call print_char
    
    ; Display " - Quantity: "
    mov dx, offset item_quantity_msg
    call print_string
    
    ; Display quantity
    mov dl, [di]
    add dl, '0'
    call print_char
    
    ; New line
    mov dl, 0Dh
    call print_char
    mov dl, 0Ah
    call print_char
    
    inc si
    inc di
    loop display_loop
    
display_done:
    pop dx
    pop cx
    pop di
    pop si
    ret
display_cart endp

; ----------------------------
; HELPER FUNCTIONS
; ----------------------------
clear_screen proc
    push ax
    push bx
    push cx
    push dx
    
    mov ax, 0600h   ; Scroll entire window
    mov bh, 07h     ; Normal attribute
    xor cx, cx      ; Upper left corner (0,0)
    mov dx, 184Fh   ; Lower right corner (24,79)
    int 10h
    
    ; Move cursor to top-left
    mov ah, 02h
    xor bh, bh
    xor dx, dx
    int 10h
    
    pop dx
    pop cx
    pop bx
    pop ax
    ret
clear_screen endp

print_string proc
    push ax
    mov ah, 09h
    int 21h
    pop ax
    ret
print_string endp

get_string proc
    push ax
    push bx
    push cx
    push dx
    push si
    
    mov si, dx      ; Buffer address
    
input_loop:
    mov ah, 01h      ; Read character with echo
    int 21h
    
    cmp al, 0Dh      ; Check for Enter key
    je input_done
    
    mov [si], al     ; Store character
    inc si
    jmp input_loop
    
input_done:
    mov byte ptr [si], '$'  ; DOS string terminator
    pop si
    pop dx
    pop cx
    pop bx
    pop ax
    ret
get_string endp

get_char proc
    mov ah, 01h
    int 21h
    ret
get_char endp

wait_key proc
    mov ah, 08h      ; Read character without echo
    int 21h
    ret
wait_key endp

print_char proc
    push ax
    mov ah, 02h
    int 21h
    pop ax
    ret
print_char endp

compare_strings proc
    push bx
    push cx
    
compare_loop:
    mov bl, [si]
    mov cl, [di]
    cmp bl, cl
    jne not_equal
    cmp bl, '$'
    je strings_equal
    inc si
    inc di
    jmp compare_loop
    
strings_equal:
    xor ax, ax
    jmp compare_done
    
not_equal:
    mov ax, 1
    
compare_done:
    pop cx
    pop bx
    ret
compare_strings endp

end main
